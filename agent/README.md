# Nexora - Real-time - Системный мониторинг и управление процессами

CLI-утилита для мониторинга и управления системными процессами с веб-интерфейсом. Поддерживает как интерактивное текстовое меню, так и REST API с WebSocket для потоковой передачи метрик в реальном времени.

## Содержание

- [Основные возможности](#основные-возможности)
- [Архитектура проекта](#архитектура-проекта)
- [Серверная часть (Web API)](#серверная-часть-web-api)
- [API Эндпоинты](#api-эндпоинты)
- [WebSocket Эндпоинты](#websocket-эндпоинты)
- [Технологический стек](#технологический-стек)
- [Запуск проекта](#запуск-проекта)

## Основные возможности

### CLI-режим

- Просмотр списка всех запущенных процессов с детальной информацией
- Завершение процессов по PID или по имени
- Поиск процессов по PID или названию
- Фоновый мониторинг процессов с превышением порога загрузки CPU
- Интерактивное текстовое меню

### Web-режим (HTTP Server)

- REST API для получения метрик системы
- WebSocket для потоковой передачи данных в реальном времени
- Управление состоянием мониторинга (включение/выключение)
- Завершение процессов через API
- Получение информации о системе и процессоре
- Мониторинг здоровья дисков через SMART
- Работа с сетевыми соединениями и интерфейсами
- Экспорт данных в CSV и JSON
- История метрик с возможностью очистки
- Запись процессов с высоким использованием ресурсов
- Система алертов при превышении порогов
- Запуск новых процессов через API

## Архитектура проекта

Проект организован следующим образом:

```
agent/
├── server/              # Серверная часть (Web API)
│   ├── api/             # Настройка HTTP-сервера и маршрутизация
│   │   ├── server.go    # Запуск сервера с graceful shutdown
│   │   └── routes.go    # Регистрация всех эндпоинтов
│   ├── handlers/        # HTTP-обработчики для REST API
│   │   ├── metrics.go   # Обработчики метрик (CPU, память, процессы)
│   │   ├── kill_process_by_pid.go  # Завершение процессов
│   │   ├── monitoring.go # Управление состоянием мониторинга
│   │   ├── device_info.go # Информация о процессоре
│   │   ├── system_info.go # Общая информация о системе
│   │   ├── disk_health.go # Здоровье дисков
│   │   ├── network_*.go # Сетевые функции
│   │   ├── export_data.go # Экспорт данных
│   │   ├── metrics_history.go # История метрик
│   │   ├── recording.go # Запись процессов
│   │   └── alerts.go # Система алертов
│   ├── ws/              # WebSocket для потоковой передачи
│   │   └── ws.go        # Потоковая передача метрик в реальном времени
│   ├── getmetrics/      # Сбор системных метрик
│   │   ├── cpu_metrics.go      # Метрики CPU
│   │   ├── memory_metrics.go   # Метрики памяти
│   │   ├── process_metrics.go  # Информация о процессах
│   │   ├── disk_health.go # Здоровье дисков через SMART
│   │   └── network_*.go # Сетевые метрики
│   ├── models/          # Структуры данных
│   │   └── process.go  # Модели для API-ответов
│   ├── services/        # Бизнес-логика
│   │   ├── metrics_history.go # Работа с историей метрик
│   │   ├── recording.go # Логика записи процессов
│   │   ├── alerts.go # Логика алертов
│   │   └── tcp_manager.go # Управление TCP соединениями
│   ├── db/              # Работа с базой данных
│   │   └── schema_monitor.go # Схема базы данных
│   └── middleware/      # Промежуточное ПО
│       └── cors_middleware.go  # CORS middleware
├── cpu/                 # CLI-логика для работы с процессами
├── ui/                  # Интерфейс командной строки
├── utils/               # Вспомогательные утилиты
└── main.go              # Точка входа приложения
```

## Серверная часть (Web API)

### Архитектура серверной части

Серверная часть построена по модульной архитектуре с четким разделением ответственности.

#### Слой API (api/)

В файле server.go происходит инициализация и запуск HTTP-сервера. Сервер поддерживает graceful shutdown, то есть корректное завершение работы при получении сигналов SIGTERM или SIGINT. Настроены таймауты для чтения, записи и простоя соединений.

В routes.go происходит централизованная регистрация всех маршрутов - как REST API эндпоинтов, так и WebSocket соединений. Это единая точка конфигурации маршрутизации.

#### Слой обработчиков (handlers/)

Обработчики отвечают за обработку HTTP запросов. В metrics.go находятся обработчики для получения метрик CPU, памяти и процессов. В kill_process_by_pid.go реализовано завершение процессов по PID с валидацией входных данных. В monitoring.go происходит управление состоянием мониторинга - включение и выключение.

Также есть обработчики для получения информации о системе (device*info.go, system_info.go), здоровья дисков (disk_health.go), работы с сетью (network*\*.go), экспорта данных (export_data.go), истории метрик (metrics_history.go), записи процессов (recording.go) и системы алертов (alerts.go).

#### Слой WebSocket (ws/)

В ws.go реализована потоковая передача метрик в реальном времени. Метрики кэшируются для оптимизации производительности, чтобы не нагружать систему постоянными запросами. Есть три типа потоков: CPU, память и процессы. Кэш обновляется автоматически - каждую секунду для CPU, каждые пять секунд для памяти и процессов.

Ключевые особенности WebSocket слоя:

- Кэширование метрик для снижения нагрузки на систему
- Управление состоянием мониторинга через API
- Потокобезопасность через использование мьютексов для безопасного доступа к данным
- Graceful shutdown для корректного завершения WebSocket соединений

#### Слой сбора метрик (getmetrics/)

В этом слое происходит сбор системных метрик. cpu_metrics.go собирает метрики использования CPU с поддержкой мгновенных и усредненных значений через библиотеку gopsutil. memory_metrics.go собирает метрики использования памяти - процент использования, используемая и общая память в мегабайтах. process_metrics.go получает список всех процессов с детальной информацией: PID, имя, процент CPU, память, статус и так далее.

Также есть модули для работы с дисками (disk_health.go) - получение информации о здоровье дисков через SMART, и сетевые модули для работы с соединениями, портами и интерфейсами.

#### Слой моделей (models/)

Здесь определены структуры данных для API ответов. В process.go находятся модели для информации о процессах, метриках CPU и памяти, ответах при завершении процессов и управлении мониторингом.

#### Слой сервисов (services/)

В этом слое находится бизнес-логика приложения. metrics_history.go отвечает за работу с историей метрик - сохранение, получение и очистку. recording.go реализует логику записи процессов с высоким использованием ресурсов. alerts.go содержит логику системы алертов - создание алертов при превышении порогов, подтверждение и управление порогами.

#### Слой базы данных (db/)

В schema_monitor.go определена схема базы данных SQLite. База данных хранит историю метрик, сессии записи процессов, записанные процессы и алерты. Для оптимизации запросов созданы индексы на часто используемых полях.

#### Слой middleware (middleware/)

В cors_middleware.go реализована обработка CORS заголовков для работы с веб-приложениями. Поддерживаются GET и POST методы, настроены разрешенные заголовки, обрабатываются preflight запросы (OPTIONS).

### Поток данных

Клиент может обращаться к серверу двумя способами: через REST API для разовых операций и через WebSocket для потоковой передачи данных.

При подключении к WebSocket эндпоинтам система проверяет состояние мониторинга. Если мониторинг включен, клиент получает реальные метрики из кэша. Если мониторинг выключен, отправляется сообщение о текущем статусе.

### Управление состоянием мониторинга

Мониторинг можно включать и выключать через POST запрос к /api/monitoring-status. Когда клиент отправляет запрос с enabled: true, система обновляет глобальное состояние и запускает горутину для обновления кэша метрик. При enabled: false горутина останавливается, и сбор метрик прекращается.

## API Эндпоинты

### REST API

REST API используется для вспомогательных операций, когда основной поток метрик приходит по WebSocket.

#### Информация о системе

##### GET `/api/get-host-username`

Получение имени хоста и текущего пользователя.

**Ответ:**

```json
{
	"username": "user",
	"hostname": "mycomputer"
}
```

##### GET `/api/get-device-info`

Получение детальной информации о процессоре, включая модель, производителя, количество физических и логических ядер, частоту, размер кэша, поддерживаемые инструкции, архитектуру, семейство и модель.

**Ответ:**

```json
{
	"processor_name": "Intel Core i7-9700K",
	"vendor": "GenuineIntel",
	"physical_cores": 8,
	"logical_processors": 8,
	"frequency_mhz": 3600.0,
	"cache_size_kb": 12288,
	"supported_flags": ["sse", "sse2", "avx", "avx2"],
	"architecture": "x86_64",
	"family": "6",
	"model": "158"
}
```

##### GET `/api/system-info`

Получение полной информации о системе, включая хост, процессор, память, нагрузку, диски и сетевые интерфейсы.

**Ответ:**

```json
{
	"host": {
		"hostname": "mycomputer",
		"os": "linux",
		"platform": "arch",
		"platformFamily": "arch",
		"platformVersion": "",
		"kernelVersion": "6.17.9",
		"kernelArch": "x86_64",
		"uptimeSec": 86400,
		"bootTime": 1700000000
	},
	"cpu": {
		"modelName": "Intel Core i7-9700K",
		"vendorId": "GenuineIntel",
		"physicalCores": 8,
		"logicalCores": 8
	},
	"memory": {
		"totalBytes": 17179869184,
		"availableBytes": 8589934592,
		"usedBytes": 8589934592,
		"usedPercent": 50.0,
		"swapTotalBytes": 4294967296,
		"swapUsedBytes": 0,
		"swapUsedPercent": 0.0
	},
	"load": {
		"load1": 1.5,
		"load5": 1.2,
		"load15": 1.0
	},
	"disks": [...],
	"interfaces": [...]
}
```

##### GET `/api/disk-health`

Получение информации о здоровье дисков через SMART. Работает только на Linux и требует установленного smartctl из пакета smartmontools. Для некоторых дисков могут потребоваться права root.

**Ответ:**

```json
{
	"supported": true,
	"message": "Данные SMART получены через smartctl",
	"devices": [
		{
			"device": "/dev/sda",
			"model": "Samsung SSD 860 EVO",
			"serial": "S3Z1NX0K123456",
			"busType": "SATA",
			"smartAvailable": true,
			"smartEnabled": true,
			"smartPassed": true,
			"temperatureC": 35,
			"powerOnHours": 8760,
			"warnings": []
		}
	]
}
```

##### GET `/api/version`

Получение версии сервера.

**Ответ:**

```json
{
	"serverVersion": 1.1.0"
}
```

#### Управление процессами

##### POST `/api/kill-process-by-id`

Завершение процесса по PID.

**Запрос:**

```json
{
	"pid": 1234
}
```

**Ответ:**

```json
{
	"pid": 1234,
	"message": "Процесс успешно завершен",
	"timestamp": "2024-01-15 14:30:25"
}
```

##### POST `/api/start-processes`

Запуск нового процесса с указанием команды, аргументов и рабочей директории.

**Запрос:**

```json
{
	"command": "/usr/bin/python3",
	"args": ["script.py", "arg1", "arg2"],
	"cwd": "/home/user/project"
}
```

**Ответ:**

```json
{
	"pid": 5678,
	"command": "/usr/bin/python3",
	"args": ["script.py", "arg1", "arg2"],
	"cwd": "/home/user/project",
	"msg": "Процесс успешно запущен"
}
```

#### Мониторинг

##### GET `/api/monitoring-status`

Получение текущего состояния мониторинга.

**Ответ:**

```json
{
	"enabled": true,
	"message": "Мониторинг включен",
	"timestamp": "2024-01-15 14:30:25"
}
```

##### POST `/api/monitoring-status`

Установка состояния мониторинга (включить/выключить).

**Запрос:**

```json
{
	"enabled": true
}
```

**Ответ:**

```json
{
	"enabled": true,
	"message": "Мониторинг успешно включен",
	"timestamp": "2024-01-15 14:30:25"
}
```

#### Сетевые функции

##### GET `/api/listening-ports`

Получение списка всех портов в состоянии LISTEN с информацией о процессах, которые их используют.

**Ответ:**

```json
[
	{
		"port": 8080,
		"protocol": "tcp",
		"pid": 1234,
		"name": "agent",
		"address": "0.0.0.0"
	}
]
```

##### GET `/api/network-connections`

Получение всех сетевых соединений. Можно указать параметр kind для фильтрации (tcp, udp, tcp4, tcp6, udp4, udp6, unix).

**Запрос:**

```
GET /api/network-connections?kind=tcp
```

**Ответ:**

```json
[
	{
		"localAddr": "127.0.0.1:8080",
		"remoteAddr": "127.0.0.1:54321",
		"status": "ESTABLISHED",
		"pid": 1234,
		"name": "agent"
	}
]
```

##### GET `/api/network-top-processes`

Получение топ процессов по количеству сетевых соединений. Можно указать параметр limit для ограничения количества результатов (по умолчанию 20).

**Запрос:**

```
GET /api/network-top-processes?limit=10
```

**Ответ:**

```json
[
	{
		"pid": 1234,
		"name": "chrome",
		"connections": 45
	}
]
```

##### GET `/api/network-interfaces`

Получение информации о сетевых интерфейсах с статистикой входящего и исходящего трафика.

**Ответ:**

```json
[
	{
		"name": "eth0",
		"bytesSent": 1024000,
		"bytesRecv": 2048000,
		"packetsSent": 1000,
		"packetsRecv": 2000,
		"errin": 0,
		"errout": 0,
		"dropin": 0,
		"dropout": 0
	}
]
```

#### Экспорт данных

##### GET `/api/export/processes`

Экспорт списка всех процессов в CSV или JSON формат. Можно указать параметр format (csv или json, по умолчанию json).

**Запрос:**

```
GET /api/export/processes?format=csv
```

Файл будет скачан с именем вида processes_20240115_143025.csv или processes_20240115_143025.json.

##### GET `/api/export/metrics`

Экспорт текущих метрик CPU и памяти в CSV или JSON формат. Можно указать параметр format (csv или json, по умолчанию json).

**Запрос:**

```
GET /api/export/metrics?format=json
```

Файл будет скачан с именем вида metrics_20240115_143025.csv или metrics_20240115_143025.json.

#### История метрик

##### GET `/api/metrics-history`

Получение истории метрик за указанный период. Можно указать параметры from (начальная дата), to (конечная дата) и limit (лимит записей, по умолчанию 1000). Формат даты: "2006-01-02 15:04:05", "2006-01-02T15:04:05" или "2006-01-02". Если параметры не указаны, возвращаются метрики за последние 7 дней.

**Запрос:**

```
GET /api/metrics-history?from=2024-01-01&to=2024-01-15&limit=500
```

**Ответ:**

```json
[
	{
		"id": 1,
		"timestamp": "2024-01-15 14:30:25",
		"cpuPercent": 45.2,
		"memoryPercent": 62.5,
		"memoryUsedMB": 8192,
		"memoryTotalMB": 16384
	}
]
```

##### POST `/api/clear-metrics`

Очистка всей истории метрик из базы данных.

**Ответ:**

```json
{
	"success": true,
	"message": "Метрики успешно очищены"
}
```

#### Запись процессов

##### POST `/api/start-recording`

Запуск новой сессии записи процессов с высоким использованием ресурсов. Требует включенного мониторинга. Записываются процессы, которые превышают указанные пороги CPU и RAM в течение указанной длительности.

**Запрос:**

```json
{
	"cpuThreshold": 80.0,
	"ramThreshold": 70.0,
	"duration": 300
}
```

**Ответ:**

```json
{
	"success": true,
	"sessionId": 1,
	"message": "Запись метрик запущена"
}
```

##### POST `/api/stop-recording`

Остановка активной сессии записи процессов.

**Ответ:**

```json
{
	"success": true,
	"message": "Запись метрик остановлена"
}
```

##### GET `/api/recording-status`

Получение статуса текущей сессии записи, включая пороги и временные метки.

**Ответ:**

```json
{
	"active": true,
	"session": {
		"id": 1,
		"cpuThreshold": 80.0,
		"ramThreshold": 70.0,
		"duration": 300,
		"startedAt": "2024-01-15T14:30:25Z",
		"endTime": "2024-01-15T14:35:25Z"
	}
}
```

##### GET `/api/recorded-processes`

Получение списка записанных процессов для указанной сессии. Требуется параметр sessionId и опциональный limit (по умолчанию 1000).

**Запрос:**

```
GET /api/recorded-processes?sessionId=1&limit=100
```

**Ответ:**

```json
[
	{
		"id": 1,
		"sessionId": 1,
		"recordedAt": "2024-01-15 14:30:25",
		"pid": 1234,
		"name": "chrome",
		"cpuPercent": 85.5,
		"memoryPercent": 75.2,
		"memoryRss": 2048000000,
		"exe": "/usr/bin/chrome",
		"cmdline": "chrome --no-sandbox",
		"username": "user"
	}
]
```

#### Система алертов

##### GET `/api/alerts`

Получение списка алертов. Можно указать параметры limit (лимит записей, по умолчанию 100) и unacknowledged_only (только неподтвержденные, true или 1).

**Запрос:**

```
GET /api/alerts?limit=50&unacknowledged_only=true
```

**Ответ:**

```json
[
	{
		"id": 1,
		"createdAt": "2024-01-15 14:30:25",
		"type": "cpu",
		"threshold": 80.0,
		"currentValue": 85.5,
		"message": "CPU usage превысил порог 80%",
		"acknowledged": 0
	}
]
```

##### POST `/api/alerts/acknowledge`

Подтверждение алерта по его ID.

**Запрос:**

```json
{
	"id": 1
}
```

**Ответ:**

```json
{
	"success": true,
	"message": "Алерт подтвержден"
}
```

##### GET `/api/alerts/thresholds`

Получение текущих порогов для CPU и памяти.

**Ответ:**

```json
{
	"cpuThreshold": 80.0,
	"memoryThreshold": 70.0
}
```

##### POST `/api/alerts/thresholds`

Установка порогов для CPU и памяти, при превышении которых будут создаваться алерты.

**Запрос:**

```json
{
	"cpuThreshold": 85.0,
	"memoryThreshold": 75.0
}
```

**Ответ:**

```json
{
	"success": true,
	"cpuThreshold": 85.0,
	"memoryThreshold": 75.0,
	"message": "Пороги установлены"
}
```

#### Дополнительные функции

##### GET `/api/get-root-status`

Проверка наличия root прав у процесса сервера.

**Ответ:**

```json
{
	"rootStatus": false
}
```

## WebSocket Эндпоинты

### `/ws/cpu`

Потоковая передача метрик CPU каждую секунду. Метрики берутся из кэша, который обновляется каждую секунду.

**Сообщения:**

```json
{
	"cpu": 45.2,
	"timestamp": "2024-01-15 14:30:25"
}
```

**При выключенном мониторинге:**

```json
{
	"monitoringEnabled": false,
	"message": "Мониторинг выключен"
}
```

### `/ws/memory`

Потоковая передача метрик памяти каждые пять секунд. Метрики берутся из кэша, который обновляется каждые пять секунд.

**Сообщения:**

```json
{
	"memoryUsage": 62.5,
	"usedMB": 8192,
	"totalMemory": 16384,
	"timestamp": "2024-01-15 14:30:25"
}
```

### `/ws/processes`

Потоковая передача списка процессов каждые пять секунд. Метрики берутся из кэша, который обновляется каждые пять секунд.

**Сообщения:**

```json
[
	{
		"pid": 1234,
		"name": "chrome",
		"cpuPercent": 15.5,
		"memoryPercent": 8.2,
		"memoryRss": 1024000000,
		"status": "R",
		"username": "user",
		"exe": "/usr/bin/chrome",
		"cmdline": "chrome --no-sandbox",
		"createTime": 1700000000000,
		"parentPid": 1000,
		"ports": [8080, 8081]
	}
]
```

## Технологический стек

- **Go 1.25.3** - основной язык программирования
- **gorilla/websocket v1.5.3** - WebSocket для потоковой передачи данных
- **gopsutil v4.25.10** - сбор системных метрик (CPU, память, процессы, сеть, диски)
- **net/http** - стандартная библиотека для HTTP-сервера
- **SQLite** - база данных для хранения истории метрик, сессий записи и алертов

## Запуск проекта

### Предварительные требования

- Go 1.25.3 или выше
- Linux, Windows или macOS
- Для функции disk-health на Linux требуется установленный smartctl (пакет smartmontools)

### Установка зависимостей

```bash
go mod download
```

### Запуск CLI-режима

```bash
go run main.go
```

В главном меню выберите:

- `1` - Работа с процессами (CLI)
- `2` - Раздел в разработке
- `3` - Запуск веб-сервера
- `4` - Переключение мониторинга
- `0` - Выход

### Запуск веб-сервера

```bash
go run main.go
# Выберите опцию 3 в меню
```

Или напрямую через код:

```go
api.StartServer("8080")
```

Сервер будет доступен по адресу: `http://localhost:8080`

При первом запуске автоматически создается база данных SQLite (monitor.db) с необходимой схемой для хранения истории метрик, сессий записи процессов и алертов.

## Безопасность

- **CORS**: Настроен для работы с веб-приложениями (в продакшене рекомендуется указать конкретные домены)
- **Валидация**: Все входные данные валидируются перед обработкой
- **Graceful Shutdown**: Корректное завершение работы без потери данных
- **Таймауты**: Настроены таймауты для предотвращения зависаний
- **Права доступа**: Некоторые функции (например, disk-health) могут требовать root прав

## Особенности реализации

### Оптимизация производительности

- Кэширование метрик для снижения нагрузки на систему
- Предварительное выделение памяти для слайсов
- Использование RWMutex для оптимизации чтения
- Синхронизация частоты обновления кэша с отправкой данных
- Индексы в базе данных для быстрого поиска

### Управление ресурсами

- Graceful shutdown для корректного завершения работы
- Управление жизненным циклом горутин через контекст
- Автоматическая остановка сбора метрик при выключении мониторинга
- Таймауты для внешних команд (например, smartctl)

### Обработка ошибок

- Полное логирование всех ошибок
- Информативные сообщения об ошибках для клиента
- Обработка ошибок сериализации JSON
- Валидация входных данных
- Обработка отсутствующих внешних утилит

### База данных

База данных SQLite используется для хранения:

- История метрик системы (CPU и память) с временными метками
- Сессии записи процессов с порогами и длительностью
- Записанные процессы с детальной информацией
- Алерты с типом, порогами и статусом подтверждения

Все таблицы имеют индексы на часто используемых полях для оптимизации запросов.

## Жизненный цикл мониторинга

1. **Старт сервера**: Мониторинг выключен по умолчанию. База данных инициализируется при первом запуске.
2. **Включение мониторинга**: Клиент отправляет POST запрос к /api/monitoring-status с enabled: true.
3. **Запуск сбора метрик**: Запускается горутина обновления кэша каждую секунду для CPU и каждые пять секунд для памяти и процессов. Также начинается сохранение метрик в базу данных и проверка порогов для создания алертов.
4. **Отправка данных**: WebSocket начинает отправлять реальные метрики из кэша клиентам.
5. **Выключение мониторинга**: Клиент отправляет POST запрос к /api/monitoring-status с enabled: false.
6. **Остановка сбора**: Горутина останавливается, WebSocket отправляет сообщение о статусе, сохранение метрик прекращается.

---

**Версия**: 1.1
**Автор**: Roman Zhurakovskiy  
**Дата обновления**: 31.01.2026
